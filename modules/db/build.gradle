/*
 * This program is part of the OpenLMIS logistics management information system platform software.
 * Copyright © 2013 VillageReach
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *  
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.
 * You should have received a copy of the GNU Affero General Public License along with this program.  If not, see http://www.gnu.org/licenses.  For additional information contact info@OpenLMIS.org. 
 */

import groovy.sql.Sql

configurations {
    classpath
}

dependencies {
    compile 'org.postgresql:postgresql:9.2-1002-jdbc4',
            'com.mchange:c3p0:0.9.2.1',
            'org.mybatis:mybatis:3.2.8',
            'org.mybatis:mybatis-spring:1.2.2'

    classpath 'org.postgresql:postgresql:9.2-1002-jdbc4'

    configurations {
        testFixtures {
            extendsFrom testRuntime
        }
    }

    task testJar(type: Jar) {
        from sourceSets.test.output
        classifier = 'test'
    }

    artifacts {
        testFixtures testJar
    }

}

flyway {
    url = "$dbUrlPrefix$databaseHostName:$databasePort/$dbName"
    driver = dbDriver
    user = dbUser
    password = dbPassword
    schemas = ['public','atomfeed']
    locations = ['filesystem:'+sourceSets.main.resources.srcDirs.first().getCanonicalPath()+'/db/migration']
    sqlMigrationPrefix = ''
    placeholderPrefix = '#['
    placeholderSuffix = ']'
}

jar.doFirst {
    tasks.migrateDB.execute()
}

task setupDB << {
    tasks.dropDB.execute()
    tasks.createDB.execute()
    tasks.migrateDB.execute()
}

task createDB << {
    println("Creating database...")
    executeSql("create database $dbName")
}

task dropDB << {
    println("Closing active connections...")
    if (!closeActiveConnections("pid")) {
        println("Could not close active connections, trying again...")
        closeActiveConnections("pid")
    }

    println("Dropping database...")
    executeSql("DROP DATABASE IF EXISTS $dbName")
}

task dropSchemas << {
    executeSql('drop schema public cascade ', true)
    executeSql('drop schema atomfeed cascade ', true)
}

task createSchemas << {
    executeSql('create schema public', true)
    executeSql('create schema atomfeed', true)
}

task migrateDB << {
    println("Migrating database...")
    tasks.flywayMigrate.execute()
}

//   Usage: gradle generateMigration [-PmigrationName=name_of_migration]
//          Defaults to 'migration' as migration name
// Example: gradle generateMigration -PmigrationName=add_column_to_users
//          Will create a file in migration folder with name yyyyMMddHHmmssSSS_add_column_to_users.sql.
task generateMigration << {
    def fileName = project.hasProperty('migrationName') ? migrationName : 'migration'
    def timestamp = new Date().format('yyyyMMddHHmmssSSS', TimeZone.getTimeZone('GMT'))
    def fullFileName = "${timestamp}__${fileName}.sql"
    def migrationFile = new File(sourceSets.main.resources.srcDirs.first(),'db/migration/'+fullFileName)
    migrationFile.createNewFile()
}

task testSeed(type: Exec) {
    environment("PGPASSWORD", dbPassword)
    commandLine 'psql', '-U', dbUser, '--file', '../../test-data/sql/seed.sql', '-h', databaseHostName, '-w', dbName
}

task demoSeed(type: Exec) {
    description 'Runs seed script to populate data for a demo; use this after setupDb and baseSeed to get working demo data'
    environment("PGPASSWORD", dbPassword)
    commandLine 'psql', '-U', dbUser, '--file', '../../test-data/sql/demo_seed.sql', '-h', databaseHostName, '-w', dbName
}

task vimsSeed(type: Exec) {
    environment("PGPASSWORD", dbPassword)
    commandLine 'psql', '-U', dbUser, '--file', '../../test-data/vims/seed.sql', '-h', databaseHostName, '-w', dbName
}

task baseSeed(type: Exec) {
    description 'Runs a base seed script, which has data that would be considered true seed/starter data'
    environment("PGPASSWORD", dbPassword)
    commandLine 'psql', '-U', dbUser, '--file', 'src/main/resources/seed/seed.sql', '-h', databaseHostName, '-w', dbName
}

task extraSeed(type: Exec, dependsOn: baseSeed) {
    description 'Runs an extra seed script; not technically seed data, but data that is necessary for the build to pass'
    environment("PGPASSWORD", dbPassword)
    // Generated by pg_dump -a -t dosage_units -t facility_operators -t facility_types -t geographic_levels -t geographic_zones -t product_forms -t product_groups -t programs -t regimen_categories --column-inserts open_lmis > modules/db/src/main/resources/seed/extra_seed.sql
    // after seed task is finished
    commandLine 'psql', '-U', dbUser, '--file', 'src/main/resources/seed/extra_seed.sql', '-h', databaseHostName, '-w', dbName
}

task globalSeed(dependsOn: [baseSeed, extraSeed]) {
    description 'Runs all seed tasks that apply globally'
}

task enableCustom(type: Exec, dependsOn: baseSeed) {
    onlyIf { toggleOnCustom == 'true' }
    description 'Runs script to enable project-specific features (if toggleOnCustom is true)'
    environment("PGPASSWORD", dbPassword)
    commandLine 'psql', '-U', dbUser, '--file', 'src/main/resources/seed/enable_custom.sql', '-h', databaseHostName, '-w', dbName
}

task seed(dependsOn: [globalSeed, enableCustom]) {
    description 'Main seed task for building; runs global seed task, then runs project-specific seed task (if toggleOnCustom is true)'
}

def boolean closeActiveConnections(String pid) {
    try {
        executeSql("SELECT pg_terminate_backend($pid) FROM pg_stat_activity WHERE datname='$dbName'")
        return true
    } catch (Exception e) {
        return false
    }
}

def executeSql(String statement, Boolean includeDbName = false) {
    def connectionString = "jdbc:postgresql://$databaseHostName:$databasePort/"

    connectionString += (includeDbName) ? "$dbName" : ""

    connectionString += (dbSslEnabled == 'true') ? "?ssl=true&sslfactory=org.postgresql.ssl.NonValidatingFactory" : ""

    configurations.classpath.each { file ->
        gradle.class.classLoader.addURL(file.toURI().toURL())
    }

    Sql.newInstance(connectionString, dbUser, dbPassword, dbDriver).execute(statement)
}

